package exhaustive_recursion.parenthetical_possibilities;

import java.util.AbstractMap;
import java.util.ArrayList;
import java.util.List;

// parenthetical possibilities
// Write a function, parentheticalPossibilities, that takes in a string as an argument.
//  The function should return an array containing all  the strings that could be
//  generated by expanding all parentheses of the string into its possibilities.

// For example, the possibilities for 'x(mn)yz' are 'xmyz', 'xnyz'.



/*
get options [m,n]
for let  i for x(mn)yz
once


*/

public class parenthetical_possibilities {

    public static List<String> parentheticalPossibilities(String str) {
        return _parentheticalPossibilities(str, 0);
    }

    public static List<String> _parentheticalPossibilities(String str, int pos) {

            return List.of("");
        
    }

    public static AbstractMap.SimpleEntry<String, List<String>> getOptions(String str) {

            String remainingChars = str.substring(1);
            List<String> chars = List.of(String.valueOf(str.charAt(0)));
            return new AbstractMap.SimpleEntry<>(remainingChars, chars);

    }

    public static void printVector(List<String> vec) {
        System.out.println(" [ ");
        for (String x : vec) {
            System.out.print(x + " , ");
        }
        System.out.println(" ] ");
    }

    public static void main(String[] args) {
        printVector(parentheticalPossibilities("x(mn)yz")); // ->
        // [ "xmyz", "xnyz" ]
        printVector(parentheticalPossibilities("(qr)ab(stu)c")); // ->
        // [ "qabsc", "qabtc", "qabuc", "rabsc", "rabtc", "rabuc" ]
        printVector(parentheticalPossibilities("taco")); // ->
        // ["taco"]
        printVector(parentheticalPossibilities("")); // ->
        // [""]
        printVector(parentheticalPossibilities("(etc)(blvd)(cat)")); // ->
        // [
        // "ebc", "eba", "ebt", "elc", "ela",
        // "elt", "evc", "eva", "evt", "edc",
        // "eda", "edt", "tbc", "tba", "tbt",
        // "tlc", "tla", "tlt", "tvc", "tva",
        // "tvt", "tdc", "tda", "tdt", "cbc",
        // "cba", "cbt", "clc", "cla", "clt",
        // "cvc", "cva", "cvt", "cdc", "cda",
        // "cdt"
        // ]

    }
}